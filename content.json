{"meta":{"title":"陈新友的博客","subtitle":null,"description":null,"author":"陈新友","url":"https://www.xinyouwx.club"},"pages":[{"title":"","date":"2018-07-23T03:38:14.719Z","updated":"2018-07-23T03:38:14.719Z","comments":true,"path":"baidu_verify_NW1yrj7RxS.html","permalink":"https://www.xinyouwx.club/baidu_verify_NW1yrj7RxS.html","excerpt":"","text":"NW1yrj7RxS"}],"posts":[{"title":"Java 动态代理","slug":"Java-动态代理","date":"2018-08-28T06:48:54.000Z","updated":"2018-08-28T07:00:17.926Z","comments":true,"path":"2018/08/28/Java-动态代理/","link":"","permalink":"https://www.xinyouwx.club/2018/08/28/Java-动态代理/","excerpt":"","text":"Java 动态代理 最近在学习spring的时候，AOP 的原理就是动态代理机制，这里对Java动态代理做一个回顾 1.在Java动态代理机制中有两个重要的类或接口，一个是InvocationHandler(Interface),一个是Proxy(Class), 这些是动态代理机制中必须用到的， 下面先看看Java API 对这两个类的描述： InvocationHandler is the interface implemented by the invocation handler of a proxy instance. Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler. 每个动态代理类都需要实现InvocationHandler ,并且每个类都关联一个Handler, 当通过代理对象调用方法的时候，这个方法调用被转发由InvocationHandler这个接口的invoke方法来调用，下面是invoke的方法： Object invoke(Object proxy, Method method, Object[] args) throws Throwable Proxy：指代理的对象 method: 指调用真实对象的方法的method对象 args: 指调用对象方法的参数 Proxy类： 官方API介绍： Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. Proxy这个类的作用就是动态创建一个代理的类，它提供了很多方法，但是我们只用到了newProxyInstance这个方法： public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException loader: 一个ClassLoader对象，定义了由那个ClassLoader对象来对生成的代理对象进行加载 interfaces: 一个interfaces对象数组，表示需要给代理对象提供接口，该对象就会实现该接口（多态） h：一个InvocationHandler对象，表示动态代理对象在调用方法的时候，会关联到该InvocationHandler对象上 2.下面我们来动手实现这个过程 假如你（被代理人）有一栋房子，需要对外出租，但是你又不想亲自去管理，那么你就把房子委托给第三方（代理）管理，你只需要负责收房租就可以了，这个过程我们可以用动态代理来实现，代码如下： 房屋的操作： public interface RentHouse { public void rent(); public void charge(String string); } 房东（你）的操作： public class HouseOwner implements RentHouse { @Override public void rent() { System.out.println(&quot;I have a beautiful house , I want rent to it &quot;); } @Override public void charge(String string) { System.out.println(&quot;house owner get :&quot; + string + &quot;money&quot;); } } 第三方的操作： public class DynamicProxy implements InvocationHandler { //这里是真实代理的对象（房东） private Object object; public DynamicProxy(Object object) { this.object = object; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //在代理真实对象前我们可以添加一些自己的操作 比如说，收取中介费， System.out.println(&quot;before &quot; + method.getName() + &quot; house&quot;); System.out.println(&quot;Method:&quot; + method.getName()); if (method.getName().equals(&quot;charge&quot;)) { //中介收取100元中介费 int result = Integer.parseInt(args[0].toString()) - 100; args[0] = String.valueOf(result); System.out.println(&quot;I will get 100 free.&quot;); } method.invoke(object, args); //在代理真实对象后我们也可以添加一些自己的操作 System.out.println(&quot;after house clean &quot;); return null; } } 客户端： public class Client { public static void main(String[] args) { // 这里是要代理的对象 HouseOwner proxySubject = new HouseOwner(); // 这个是第三方的操作，代理那个，就把那个对象传进去 InvocationHandler handler = new DynamicProxy(proxySubject); /** 通过Proxy的 newProxyInstance 方法来创建代理对象， * 第一个参数是handler.getClass().getClassLoader() ,这里我们用handler类的ClassLoader对象来加载需要代理的对象 * 通俗的将就是，我们需要第三方的加载器来加载这个房东对象，来行使房东对外出租房子的事情， * 第二个参数是proxySubject.getClass().getInterfaces()，这里是为代理对象提供真实对象的接口，表示可以直接调用该对象的接口 * 第三个参数是handler 表示代理对象关联上了InvocationHandler对象上了 */ //动态代理类 RentHouse subjectSt = (RentHouse) Proxy.newProxyInstance(handler.getClass().getClassLoader(), proxySubject.getClass().getInterfaces(), handler); System.out.println(&quot;123&quot; + subjectSt.getClass().getName()); subjectSt.rent(); // 这里输入1000 ，看看房东到手多少钱 subjectSt.charge(&quot;1000&quot;); } } 运行输出： 123com.sun.proxy.$Proxy0 before rent house Method:rent I have a beautiful house , I want rent to it after house clean before charge house Method:charge I will get 100 free. house owner get :900money after house clean 3.动态代理的局限性 从动态代理的使用方法中我们看到其实可以被增强的方法都是实现了借口的（不实现借口的public方法也可以通过继承被代理类来使用），代码中的HouseOwner继承了RentHouse，而对于private方法JDK的动态代理无能为力","categories":[],"tags":[]},{"title":"Ubuntu 安装redis集群","slug":"Ubuntu-安装redis集群","date":"2018-07-18T10:00:24.000Z","updated":"2018-07-18T10:11:12.081Z","comments":true,"path":"2018/07/18/Ubuntu-安装redis集群/","link":"","permalink":"https://www.xinyouwx.club/2018/07/18/Ubuntu-安装redis集群/","excerpt":"","text":"1.先安装 Redis，保证Redis能在单节点运行 sudo wget http://download.redis.io/releases/redis-3.2.6.tar.gz 2.解压文件 sudo tar -zxvf redis-3.2.6.tar.gz 我把redis-3.2.6/ 移动到了/usr/local/目录下 3.安装gcc apt-get install gcc sudo apt-get install build-essential 4.进入到redis-3.2.6目录下，依次执行下面两条命令： sudo make sudo make install 会在redis-3.2.6目录下，生成src文件 ，会生成redis-server等运行命令 5.更改redis.conf文件 该文件在redis-3.2.6文件目录下 将“daemonize no”修改为“daemonize yes” 更改bind 127.0.0.1 改为自己局域网IP（可以不改） cd /usr/local/redis-3.2.6/ src/redis-server redis.conf 启动成功输入： redis-cli -p 6379 然后执行命令ping 输入pong，则证明服务启动成功执行命令， set key helloword get key 6.搭建集群 准备三台机器，36，38，39首先在/usr/local/目录下 新建redis-cluster目录，然后cd redis-cluster新建7000,7001目录 复制redis-server文件分别到7000,7001目录中并新建redis.conf 文件，添加如下内容到redis.conf port 7000 #端口 和目录一样 cluster-enabled yes cluster-config-file nodes.conf bind 192.168.244.38 #绑定IP地址，如果不添加，添加集群的时候会报错， cluster-node-timeout 5000 daemonize yes # 后台运行 appendonly yes 另外两台机器一样配置，注意IP地址的更改在所有集群都配置完以后，依次运行一下命令 #!/bin/bash pkill -9 redis; cd /usr/local/redis-cluster/7000/ /usr/local/redis-cluster/7000/redis-server /usr/local/redis-cluster/7000/redis.conf; cd /usr/local/redis-cluster/7001/ /usr/local/redis-cluster/7001/redis-server /usr/local/redis-cluster/7001/redis.conf; 所有机器启动完成以后，找一台机器，安装ruby sudo apt-get update sudo apt-get install ruby sudo gem install redis 安装完成以后进入 redis-3.2.6/src/文件目录下，运行一下文件 ./redis-trib.rb create --replicas 1 192.168.244.36:7000 192.168.244.38:7000 192.168.244.39:7000 192.168.244.36:7001 192.168.244.38:7001 192.168.244.39:7001 成功以后会出现一下信息： &gt;&gt;&gt; Creating cluster &gt;&gt;&gt; Performing hash slots allocation on 6 nodes... Using 3 masters: 192.168.244.36:7000 192.168.244.38:7000 192.168.244.39:7000 Adding replica 192.168.244.38:7001 to 192.168.244.36:7000 Adding replica 192.168.244.36:7001 to 192.168.244.38:7000 Adding replica 192.168.244.39:7001 to 192.168.244.39:7000 M: 0ee8340c886afde83aa209d36d02cc7d9c4ff465 192.168.244.36:7000 slots:0-5460 (5461 slots) master M: c0823aefa158d8af30ac1c58c3753be5db7d69bd 192.168.244.38:7000 slots:5461-10922 (5462 slots) master M: 4f4bb2f4f67f4a292bf2c5ec7445f0460e0a4249 192.168.244.39:7000 slots:10923-16383 (5461 slots) master S: e371a20971b26f92af75448e08fdce4d22bcd40c 192.168.244.36:7001 replicates c0823aefa158d8af30ac1c58c3753be5db7d69bd S: a3c4e314d3b5996fa79d17f60bec0d8debf3bfa4 192.168.244.38:7001 replicates 0ee8340c886afde83aa209d36d02cc7d9c4ff465 S: be8743b28ae71f7708f8d5ef40bc6469687e7300 192.168.244.39:7001 replicates 4f4bb2f4f67f4a292bf2c5ec7445f0460e0a4249 Can I set the above configuration? (type &apos;yes&apos; to accept): yes 输入yes以后出现以下信息： &gt;&gt;&gt; Nodes configuration updated &gt;&gt;&gt; Assign a different config epoch to each node &gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join... &gt;&gt;&gt; Performing Cluster Check (using node 192.168.244.36:7000) M: 0ee8340c886afde83aa209d36d02cc7d9c4ff465 192.168.244.36:7000 slots:0-5460 (5461 slots) master 1 additional replica(s) S: e371a20971b26f92af75448e08fdce4d22bcd40c 192.168.244.36:7001 slots: (0 slots) slave replicates c0823aefa158d8af30ac1c58c3753be5db7d69bd M: c0823aefa158d8af30ac1c58c3753be5db7d69bd 192.168.244.38:7000 slots:5461-10922 (5462 slots) master 1 additional replica(s) S: be8743b28ae71f7708f8d5ef40bc6469687e7300 192.168.244.39:7001 slots: (0 slots) slave replicates 4f4bb2f4f67f4a292bf2c5ec7445f0460e0a4249 S: a3c4e314d3b5996fa79d17f60bec0d8debf3bfa4 192.168.244.38:7001 slots: (0 slots) slave replicates 0ee8340c886afde83aa209d36d02cc7d9c4ff465 M: 4f4bb2f4f67f4a292bf2c5ec7445f0460e0a4249 192.168.244.39:7000 slots:10923-16383 (5461 slots) master 1 additional replica(s) [OK] All nodes agree about slots configuration. &gt;&gt;&gt; Check for open slots... &gt;&gt;&gt; Check slots coverage... [OK] All 16384 slots covered. 集群安装成功，检查集群健康命令： ./redis-trib.rb check 192.168.244.36:7000","categories":[],"tags":[]},{"title":"Ubuntu 更改IP不生效问题","slug":"Ubuntu-更改IP不生效问题","date":"2018-07-18T02:52:24.000Z","updated":"2018-07-18T02:59:37.704Z","comments":true,"path":"2018/07/18/Ubuntu-更改IP不生效问题/","link":"","permalink":"https://www.xinyouwx.club/2018/07/18/Ubuntu-更改IP不生效问题/","excerpt":"","text":"Ubuntu 修改IP地址不生效1、Ubuntu修改静态IP不生效 source /etc/network/interfaces.d/* # The loopback network interface auto lo iface lo inet loopback # The primary network interface auto ens33 iface ens33 inet static address 192.168.244.36 netmask 255.255.0.0 gateway 192.168.0.1 service networking restart 和ifdown ens33 都不生效，ifconfig 结果还是原来的地址解决方案： ip addr flush dev ens33 ifdown ens33 ifup ens33","categories":[],"tags":[]},{"title":"Ubuntu 换源","slug":"Ubuntu-换源","date":"2018-07-18T02:04:31.000Z","updated":"2018-07-18T02:15:43.678Z","comments":true,"path":"2018/07/18/Ubuntu-换源/","link":"","permalink":"https://www.xinyouwx.club/2018/07/18/Ubuntu-换源/","excerpt":"","text":"1.备份原source.list 2.替换为一下内容 deb http://cn.archive.ubuntu.com/ubuntu/ xenial main restricted universe multiverse deb http://cn.archive.ubuntu.com/ubuntu/ xenial-security main restricted universe multiverse deb http://cn.archive.ubuntu.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://cn.archive.ubuntu.com/ubuntu/ xenial-backports main restricted universe multiverse","categories":[],"tags":[]},{"title":"Ubuntu 16.04设置IP、网关、DNS","slug":"Ta","date":"2018-07-18T01:15:00.000Z","updated":"2018-07-18T01:32:42.957Z","comments":true,"path":"2018/07/18/Ta/","link":"","permalink":"https://www.xinyouwx.club/2018/07/18/Ta/","excerpt":"","text":"Ubuntu 16.04设置IP、网关、DNS1、修改IP地址 打开/etc/network/interfaces sudo vim /etc/network/interfaces 加入以下语句： auto eth0 #要设置的网卡 iface eth0 inet static #设置静态IP；如果是使用自动IP用dhcp，后面的不用设置，一般少用 address 192.168.244.35#IP地址 netmask 255.255.0.0 #子网掩码 gateway 192.168.0.1 #网关 2、修改DNS 打开/etc/resolv.conf sudo vim /etc/resolv.conf 注意：上面设置的文件重启后会覆盖，如果要持久的保存，需要修改：/etc/resolvconf/resolv.conf.d/base 改为如下内容： search localdomain #如果本Server为DNS服务器，可以加上这一句，如果不是，可以不加 nameserver 172.16.3.4 #希望修改成的DNS nameserver 172.16.3.3 #希望修改成的DNS 3、重启服务生效 先运行一次，然后在rc.local里加入这个重启网络配置的命令： sudo /etc/init.d/networking restart #使网卡配置生效 sudo /etc/init.d/resolvconf restart #使DNS生效 service networking restart","categories":[],"tags":[]},{"title":"Ubuntu安装FastDFS 5.05","slug":"个人博客","date":"2018-06-28T02:04:00.000Z","updated":"2018-06-29T07:55:40.108Z","comments":true,"path":"2018/06/28/个人博客/","link":"","permalink":"https://www.xinyouwx.club/2018/06/28/个人博客/","excerpt":"","text":"Ubuntu下部署FastDFS 5.05 下载安装libfastcommon git clone https://github.com/happyfish100/libfastcommon.git cd libfastcommon/ ./make.sh ./make.sh install 确认make没有错误后，执行安装，64位系统默认会复制到/usr/lib64下。这时候需要设置环境变量或者创建软链接 export LD_LIBRARY_PATH=/usr/lib64/ ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so 下载安装fastdfs tar xzf FastDFS.tar.gz cd FastDFS/ ./make.sh ./make.sh install 确认make没有错误后，执行安装，默认会安装到/usr/bin中，并在/etc/fdfs中添加三个配置文件。 修改配置文件 文件要自己创建 首先将三个文件的名字去掉sample，暂时只修改以下几点，先让fastdfs跑起来，其余参数调优的时候再考虑。 tracker.conf 中修改 base_path=/usr/fastdfs #用于存放日志。 storage.conf 中修改 base_path=/usr/fastdfs-storaged #用于存放日志。 store_path0=/usr/fastdfs0 #存放数据，若不设置默认为前面那个。 tracker_server=192.168.128.128:22122 #指定tracker服务器地址。 client.conf 中修改 base_path=/usr/fastdfs #用于存放日志。 tracker_server=192.168.128.128:22122 #指定tracker服务器地址。 启动tracker和storage /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf /usr/bin/fdfs_storaged /etc/fdfs/storage.conf 检查进程 root@ubuntu:~# ps -ef |grep fdfs root 7819 1 0 15:24 ? 00:00:00 /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf root 8046 1 0 15:36 ? 00:00:01 fdfs_storaged /etc/fdfs/storage.conf start 表示启动ok了，若有错误，可以在/usr/fastdfs目录下检查日志。 上传/删除测试 使用自带的fdfs_test来测试，使用格式如下： root@ubuntu:~# fdfs_test /etc/fdfs/client.conf upload /home/steven/01.jpg group_name=group1, ip_addr=192.168.29.132, port=23000 storage_upload_by_filename group_name=group1, remote_filename=M00/00/00/wKgdhFTV0ZmAP3AZAPk-Io7D4w8580.jpg example file url: http://192.168.29.132/group1/M00/00/00/wKgdhFTV0ZmAP3AZAPk-Io7D4w8580.jpg storage_upload_slave_by_filename group_name=group1, remote_filename=M00/00/00/wKgdhFTV0ZmAP3AZAPk-Io7D4w8580_big.jpg example file url: http://192.168.29.132/group1/M00/00/00/wKgdhFTV0ZmAP3AZAPk-Io7D4w8580_big.jpg 7、使用fdfs_delete_file来删除文件，格式如下： fdfs_delete_file /etc/fdfs/client.conf group1/M00/00/00/wKgdhFTV11uAXgKWAPk-Io7D4w8667.jpg 可以看到，上传ok了，这里会生成两个文件，这是fastdfs的主/从文件特性，以后再介绍。 example file url 是不能在浏览器中直接打开的，除非配合nginx使用，这里我不需要了。 删除文件需要完整的group_name和remote_filename。 8、建议的关闭防火墙命令 iptables -P INPUT ACCEPT iptables -P FORWARD ACCEPT iptables -P OUTPUT ACCEPT iptables -F 9、安装nginx FastDFS的nginx插件fastdfs-nginx-module_v1.16.tar.gz tar zxvf fastdfs-nginx-module_v1.16.tar.gz","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-06-27T09:38:39.938Z","updated":"2018-06-27T09:38:39.938Z","comments":true,"path":"2018/06/27/hello-world/","link":"","permalink":"https://www.xinyouwx.club/2018/06/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}